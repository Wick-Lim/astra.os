use core::fmt;
use lazy_static::lazy_static;
use spin::Mutex;
use x86_64::instructions::port::Port;
use embedded_graphics::{
    pixelcolor::{Rgb888, RgbColor},
    prelude::*,
};

/// VGA Mode 13h 해상도
pub const WIDTH: usize = 320;
pub const HEIGHT: usize = 200;

/// VGA 메모리 시작 주소 (Mode 13h)
const VGA_ADDRESS: usize = 0xA0000;

/// VGA Mode 13h 픽셀 기반 프레임버퍼
pub struct Framebuffer {
    // 슬라이스 대신 포인터 사용
    buffer_ptr: *mut u8,
}

impl Framebuffer {
    /// 새로운 프레임버퍼 생성 (public으로 export)
    pub unsafe fn new() -> Self {
        Self {
            buffer_ptr: VGA_ADDRESS as *mut u8,
        }
    }

    /// 화면 전체를 특정 색으로 채우기
    pub fn clear(&mut self, color: u8) {
        unsafe {
            core::ptr::write_bytes(self.buffer_ptr, color, WIDTH * HEIGHT);
        }
    }

    /// 특정 위치에 픽셀 그리기
    pub fn draw_pixel(&mut self, x: usize, y: usize, color: u8) {
        if x >= WIDTH || y >= HEIGHT {
            return;
        }
        let offset = y * WIDTH + x;
        unsafe {
            self.buffer_ptr.add(offset).write_volatile(color);
        }
    }

    /// RGB888을 256색 팔레트 인덱스로 변환 (간단한 양자화)
    fn rgb_to_palette(color: Rgb888) -> u8 {
        // 3-3-2 비트 RGB 팔레트 (216색 + 40 그레이스케일)
        let r = (color.r() >> 5) & 0x07; // 3비트
        let g = (color.g() >> 5) & 0x07; // 3비트
        let b = (color.b() >> 6) & 0x03; // 2비트
        ((r << 5) | (g << 2) | b) as u8
    }

    /// RGB888 색상으로 픽셀 그리기
    pub fn draw_pixel_rgb(&mut self, x: usize, y: usize, color: Rgb888) {
        let palette_index = Self::rgb_to_palette(color);
        self.draw_pixel(x, y, palette_index);
    }

    /// 채워진 사각형 그리기 (VGA 메모리용 write_volatile 사용)
    pub fn fill_rect(&mut self, x: usize, y: usize, width: usize, height: usize, color: u8) {
        // 경계 체크
        if x >= WIDTH || y >= HEIGHT {
            return;
        }

        // 실제로 그릴 수 있는 영역 계산
        let actual_width = core::cmp::min(width, WIDTH - x);
        let actual_height = core::cmp::min(height, HEIGHT - y);

        // write_volatile로 픽셀 단위 쓰기 (VGA 메모리는 volatile 필수!)
        unsafe {
            for dy in 0..actual_height {
                let row_offset = (y + dy) * WIDTH + x;
                for dx in 0..actual_width {
                    self.buffer_ptr.add(row_offset + dx).write_volatile(color);
                }
            }
        }
    }

    /// RGB888 색상으로 채워진 사각형 그리기
    pub fn fill_rect_rgb(&mut self, x: usize, y: usize, width: usize, height: usize, color: Rgb888) {
        let palette_index = Self::rgb_to_palette(color);
        self.fill_rect(x, y, width, height, palette_index);
    }

    /// 사각형 테두리 그리기
    pub fn draw_rect(&mut self, x: usize, y: usize, width: usize, height: usize, color: u8) {
        // 상단
        for dx in 0..width {
            if x + dx < WIDTH && y < HEIGHT {
                self.draw_pixel(x + dx, y, color);
            }
        }
        // 하단
        if y + height > 0 && y + height - 1 < HEIGHT {
            for dx in 0..width {
                if x + dx < WIDTH {
                    self.draw_pixel(x + dx, y + height - 1, color);
                }
            }
        }
        // 좌측
        for dy in 0..height {
            if x < WIDTH && y + dy < HEIGHT {
                self.draw_pixel(x, y + dy, color);
            }
        }
        // 우측
        if x + width > 0 && x + width - 1 < WIDTH {
            for dy in 0..height {
                if y + dy < HEIGHT {
                    self.draw_pixel(x + width - 1, y + dy, color);
                }
            }
        }
    }

    /// RGB888 색상으로 사각형 테두리 그리기
    pub fn draw_rect_rgb(&mut self, x: usize, y: usize, width: usize, height: usize, color: Rgb888) {
        let palette_index = Self::rgb_to_palette(color);
        self.draw_rect(x, y, width, height, palette_index);
    }
}

/// embedded-graphics DrawTarget 구현
impl DrawTarget for Framebuffer {
    type Color = Rgb888;
    type Error = core::convert::Infallible;

    fn draw_iter<I>(&mut self, pixels: I) -> Result<(), Self::Error>
    where
        I: IntoIterator<Item = Pixel<Self::Color>>,
    {
        for Pixel(coord, color) in pixels.into_iter() {
            if coord.x >= 0 && coord.y >= 0 {
                self.draw_pixel_rgb(coord.x as usize, coord.y as usize, color);
            }
        }
        Ok(())
    }
}

impl OriginDimensions for Framebuffer {
    fn size(&self) -> Size {
        Size::new(WIDTH as u32, HEIGHT as u32)
    }
}

/// VGA Mode 13h 설정
pub fn set_mode_13h() {
    unsafe {
        let mut misc_output = Port::<u8>::new(0x3C2);
        let mut sequencer_index = Port::<u8>::new(0x3C4);
        let mut sequencer_data = Port::<u8>::new(0x3C5);
        let mut crtc_index = Port::<u8>::new(0x3D4);
        let mut crtc_data = Port::<u8>::new(0x3D5);
        let mut graphics_index = Port::<u8>::new(0x3CE);
        let mut graphics_data = Port::<u8>::new(0x3CF);
        let mut attribute_index = Port::<u8>::new(0x3C0);
        let mut input_status = Port::<u8>::new(0x3DA);

        // Mode 13h 레지스터 값들
        let sequencer_regs: [u8; 5] = [0x03, 0x01, 0x0F, 0x00, 0x0E];
        let crtc_regs: [u8; 25] = [
            0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F,
            0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x9C, 0x0E, 0x8F, 0x28, 0x40, 0x96, 0xB9, 0xA3, 0xFF
        ];
        let graphics_regs: [u8; 9] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF];
        let attribute_regs: [u8; 21] = [
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
            0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
            0x41, 0x00, 0x0F, 0x00, 0x00
        ];

        // Miscellaneous Output Register 설정
        misc_output.write(0x63);

        // Sequencer Registers 설정
        for (i, &val) in sequencer_regs.iter().enumerate() {
            sequencer_index.write(i as u8);
            sequencer_data.write(val);
        }

        // CRTC Registers 해제 (write protect 해제)
        crtc_index.write(0x03);
        let val = crtc_data.read();
        crtc_data.write(val | 0x80);
        crtc_index.write(0x11);
        let val = crtc_data.read();
        crtc_data.write(val & !0x80);

        // CRTC Registers 설정
        for (i, &val) in crtc_regs.iter().enumerate() {
            crtc_index.write(i as u8);
            crtc_data.write(val);
        }

        // Graphics Controller Registers 설정
        for (i, &val) in graphics_regs.iter().enumerate() {
            graphics_index.write(i as u8);
            graphics_data.write(val);
        }

        // Attribute Controller Registers 설정
        // Input Status Register를 읽어서 flip-flop 리셋
        input_status.read();

        for (i, &val) in attribute_regs.iter().enumerate() {
            attribute_index.write(i as u8);
            attribute_index.write(val);
        }

        // Attribute Controller 활성화
        attribute_index.write(0x20);
    }
}

/// VGA 팔레트 설정 (3-3-2 RGB)
pub fn setup_palette() {
    unsafe {
        let mut dac_index = Port::<u8>::new(0x3C8);
        let mut dac_data = Port::<u8>::new(0x3C9);

        // 256색 팔레트 설정
        for i in 0..256 {
            dac_index.write(i as u8);

            // 3-3-2 비트 RGB 팔레트
            let r = ((i >> 5) & 0x07) as u8;  // 3비트
            let g = ((i >> 2) & 0x07) as u8;  // 3비트
            let b = (i & 0x03) as u8;         // 2비트

            // VGA DAC는 6비트 값을 사용하므로 스케일링
            dac_data.write((r << 3) | (r >> 0)); // 0-7 -> 0-63
            dac_data.write((g << 3) | (g >> 0));
            dac_data.write((b << 4) | (b << 2) | b); // 0-3 -> 0-63
        }
    }
}

/// 전역 프레임버퍼
static mut FRAMEBUFFER: Option<Framebuffer> = None;

/// 프레임버퍼 초기화
pub fn init() {
    use crate::serial_println;

    serial_println!("  Setting VGA Mode 13h...");
    set_mode_13h();
    serial_println!("  VGA Mode 13h set");

    serial_println!("  Setting up palette...");
    setup_palette();
    serial_println!("  Palette configured");

    unsafe {
        FRAMEBUFFER = Some(Framebuffer::new());
    }
    serial_println!("  Framebuffer structure initialized");
}

/// 프레임버퍼에 안전하게 접근
fn with_fb<F, R>(f: F) -> R
where
    F: FnOnce(&mut Framebuffer) -> R,
    R: Default,
{
    unsafe {
        if let Some(ref mut fb) = FRAMEBUFFER {
            f(fb)
        } else {
            R::default()
        }
    }
}

/// 화면 전체를 특정 색으로 채우기
pub fn clear_screen(color: Rgb888) {
    with_fb(|fb| fb.fill_rect_rgb(0, 0, WIDTH, HEIGHT, color))
}

/// 픽셀 그리기
pub fn draw_pixel(x: usize, y: usize, color: Rgb888) {
    with_fb(|fb| fb.draw_pixel_rgb(x, y, color))
}

/// 채워진 사각형 그리기
pub fn fill_rect(x: usize, y: usize, width: usize, height: usize, color: Rgb888) {
    with_fb(|fb| fb.fill_rect_rgb(x, y, width, height, color))
}

/// 사각형 테두리 그리기
pub fn draw_rect(x: usize, y: usize, width: usize, height: usize, color: Rgb888) {
    with_fb(|fb| fb.draw_rect_rgb(x, y, width, height, color))
}

/// embedded-graphics를 사용한 도형 그리기
pub fn with_framebuffer<F>(f: F)
where
    F: FnOnce(&mut Framebuffer),
{
    with_fb(f)
}

// Simple 8x8 bitmap font (ASCII 32-126)
static SIMPLE_FONT: [[u8; 8]; 95] = [
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // Space (32)
    [0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00], // !
    [0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // "
    [0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00], // #
    [0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00], // $
    [0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00], // %
    [0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00], // &
    [0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00], // '
    [0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00], // (
    [0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00], // )
    [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00], // *
    [0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00], // +
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06], // ,
    [0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00], // -
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00], // .
    [0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00], // /
    [0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00], // 0
    [0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00], // 1
    [0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00], // 2
    [0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00], // 3
    [0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00], // 4
    [0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00], // 5
    [0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00], // 6
    [0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00], // 7
    [0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00], // 8
    [0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00], // 9
    [0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00], // :
    [0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06], // ;
    [0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00], // <
    [0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00], // =
    [0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00], // >
    [0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00], // ?
    [0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00], // @
    [0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00], // A
    [0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00], // B
    [0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00], // C
    [0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00], // D
    [0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00], // E
    [0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00], // F
    [0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00], // G
    [0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00], // H
    [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00], // I
    [0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00], // J
    [0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00], // K
    [0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00], // L
    [0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00], // M
    [0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00], // N
    [0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00], // O
    [0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00], // P
    [0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00], // Q
    [0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00], // R
    [0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00], // S
    [0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00], // T
    [0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00], // U
    [0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00], // V
    [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00], // W
    [0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00], // X
    [0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00], // Y
    [0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00], // Z
    [0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00], // [
    [0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00], // \
    [0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00], // ]
    [0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00], // ^
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF], // _
    [0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00], // `
    [0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00], // a
    [0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00], // b
    [0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00], // c
    [0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00], // d
    [0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00], // e
    [0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00], // f
    [0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F], // g
    [0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00], // h
    [0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00], // i
    [0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E], // j
    [0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00], // k
    [0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00], // l
    [0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00], // m
    [0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00], // n
    [0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00], // o
    [0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F], // p
    [0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78], // q
    [0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00], // r
    [0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00], // s
    [0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00], // t
    [0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00], // u
    [0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00], // v
    [0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00], // w
    [0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00], // x
    [0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F], // y
    [0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00], // z
    [0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00], // {
    [0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00], // |
    [0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00], // }
    [0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // ~
];

/// Draw a single character at (x, y) with given color
pub fn draw_char(ch: char, x: usize, y: usize, color: Rgb888) {
    let idx = ch as usize;
    if idx < 32 || idx > 126 {
        return; // Out of range
    }

    let glyph = SIMPLE_FONT[idx - 32];

    with_fb(|fb| {
        for row in 0..8 {
            let byte = glyph[row];
            for col in 0..8 {
                if (byte & (1 << (7 - col))) != 0 {
                    fb.draw_pixel_rgb(x + col, y + row, color);
                }
            }
        }
    })
}

/// Draw a string at (x, y) with given color
/// Returns the x position after the last character
pub fn draw_string(s: &str, x: usize, y: usize, color: Rgb888) -> usize {
    let mut current_x = x;

    for ch in s.chars() {
        if ch == '\n' {
            // Newline support - would need y tracking
            break;
        }

        if current_x + 8 > WIDTH {
            // Reached edge of screen
            break;
        }

        draw_char(ch, current_x, y, color);
        current_x += 8; // Move to next character position
    }

    current_x
}

/// Draw multiline text with automatic line wrapping
pub fn draw_text(text: &str, x: usize, y: usize, color: Rgb888, max_width: usize) {
    let mut current_x = x;
    let mut current_y = y;
    let line_height = 10; // 8 pixels + 2 spacing

    for ch in text.chars() {
        if ch == '\n' || current_x + 8 > x + max_width {
            // Move to next line
            current_x = x;
            current_y += line_height;

            if current_y + 8 > HEIGHT {
                break; // Reached bottom of screen
            }

            if ch == '\n' {
                continue; // Skip the newline character
            }
        }

        draw_char(ch, current_x, current_y, color);
        current_x += 8;
    }
}
